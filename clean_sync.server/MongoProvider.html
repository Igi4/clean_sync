        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>MongoProvider class / clean_sync.server Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="clean_sync.server" data-type="MongoProvider">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../clean_sync.server.html">clean_sync.server</a> &rsaquo; <a href="../clean_sync.server/MongoProvider.html">MongoProvider</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>MongoProvider</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class MongoProvider implements DataProvider {
 final DbCollection collection, _collectionHistory, _lock;
 List&lt;Map&gt; _selectorList = [];

 Future&lt;int&gt; get _maxVersion =&gt; _collectionHistory.count();

 MongoProvider(this.collection, this._collectionHistory, this._lock);

 MongoProvider find(Map params) {
   var mp = new MongoProvider(collection, _collectionHistory, _lock);
   mp._selectorList = new List.from(this._selectorList);
   mp._selectorList.add(params);
   return mp;
 }

 /**
  * Returns data and version of this data.
  */
 Future&lt;Map&gt; data() {
   Map selector = _selectorList.isEmpty ? {} : {AND: _selectorList};
   print(selector);
   return collection.find(selector).toList().then((data) {
     var version = data.length == 0 ? 0 :
       data.map((item) =&gt; item['__clean_version']).reduce(max);
     return {'data': data, 'version': version};
   });
 }

 Future add(Map data, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       data[VERSION_FIELD_NAME] = nextVersion;
       return collection.insert(data);
     }).then((_) =&gt;
       _collectionHistory.insert({
         "before" : {},
         "after" : data,
         "change" : {},
         "action" : "add",
         "author" : author,
         "version" : nextVersion
       }),
     onError: (e) {
       print(e);
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks());
 }

 Future change(String _id, Map change, String author) {
   num nextVersion;
   Map newRecord;
   return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
     .then((Map record) {
       if(record == null) {
         throw new MongoException(null,
             'Change was not applied, document with id $_id does not exist.');
       } else {
         return _maxVersion.then((version) {
           nextVersion = version + 1;
           newRecord = new Map.from(record);
           newRecord.addAll(change);
           newRecord[VERSION_FIELD_NAME] = nextVersion;
           return collection.save(newRecord);
         }).then((_) =&gt;
           _collectionHistory.insert({
             "before" : record,
             "after" : newRecord,
             "change" : change,
             "action" : "change",
             "author" : author,
             "version" : nextVersion
           }));
       }
     },
     onError: (e) {
       print(e);
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks());
 }

 Future remove(String _id, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       return collection.findOne({'_id': _id});
     }).then((record) {
       if (record == null) {
         return true;
       } else {
         return collection.remove({'_id': _id}).then((_) =&gt;
           _collectionHistory.insert({
             "before" : record,
             "after" : {},
             "change" : {},
             "action" : "remove",
             "author" : author,
             "version" : nextVersion
         }));
       }
     },
     onError: (e) {
       print(e);
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks());
 }

 Future&lt;Map&gt; diffFromVersion(num version) {
   try{
     return _diffFromVersion(version).then((d) =&gt; {'diff': d});
   } on DiffNotPossibleException catch(e) {
     return data().then((d) {
       d['diff'] = null;
       return d;
     });
   }
 }

 Future&lt;List&lt;Map&gt;&gt; _diffFromVersion(num version) {
   // if (some case not covered so far) {
   // throw new DiffNotPossibleException('diff not possible');
   // selects records that fulfilled _selector before change
   Map beforeSelector = {QUERY : {}, ORDERBY : {"version" : 1}};
   // selects records that fulfill _selector after change
   Map afterSelector = {QUERY : {}, ORDERBY : {"version" : 1}};
   // selects records that fulfill _selector before or after change
   Map beforeOrAfterSelector = {QUERY : {}, ORDERBY : {"version" : 1}};

   // {before: {GT: {}}} to handle selectors like {before.age: null}
   List&lt;Map&gt; _beforeSelector = [{"version" : {GT : version}}, {"before" : {GT: {}}}];
   List&lt;Map&gt; _afterSelector = [{"version" : {GT : version}}, {"after" : {GT: {}}}];
   _selectorList.forEach((item) {
     Map itemB = {};
     Map itemA = {};
     item.forEach((key, val) {
       itemB["before.${key}"] = val;
       itemA["after.${key}"] = val;
     });
     _beforeSelector.add(itemB);
     _afterSelector.add(itemA);
   });
   beforeSelector[QUERY][AND] = _beforeSelector;
   afterSelector[QUERY][AND] = _afterSelector;
   beforeOrAfterSelector[QUERY][OR] = [{AND: _beforeSelector},
                                       {AND: _afterSelector}];

   Set before, after;
   List beforeOrAfter, diff;

   return _collectionHistory.find(beforeOrAfterSelector).toList()
     .then((result) {
       beforeOrAfter = result;
       return Future.wait([
         _collectionHistory.find(beforeSelector).toList(),
         _collectionHistory.find(afterSelector).toList()]);})
     .then((results) {
         before = new Set.from(results[0].map((d) =&gt; d['_id']));
         after = new Set.from(results[1].map((d) =&gt; d['_id']));
         diff = [];

         beforeOrAfter.forEach((record) {
           if(before.contains(record['_id']) &amp;&amp; after.contains(record['_id']))
           {
             // record was changed
             diff.add({
               "action" : "change",
               "_id" : record["before"]["_id"],
               "data" : record["change"],
               "version" : record["version"],
               "author" : record["author"],
             });
           } else if(before.contains(record['_id'])) {
             // record was removed
             diff.add({
               "action" : "remove",
               "_id" : record["before"]["_id"],
               "version" : record["version"],
               "author" : record["author"],
             });
           } else {
             // record was added
             diff.add({
               "action" : "add",
               "_id" : record["after"]["_id"],
               "data" : record["after"],
               "version" : record["version"],
               "author" : record["author"],
             });
           }
         });
         return diff;
     });
 }

 Future _get_locks() {
   return _lock.insert({'_id': collection.collectionName}).then(
     (_) =&gt; _lock.insert({'_id': _collectionHistory.collectionName}),
     onError: (e) {
       if(e['code'] == 11000) {
         // duplicate key error index
         return _get_locks();
       } else {
         throw(e);
       }
     }).then((_) =&gt; true);
 }

 Future _release_locks() {
   return _lock.remove({'_id': _collectionHistory.collectionName}).then((_) =&gt;
   _lock.remove({'_id': collection.collectionName})).then((_) =&gt;
   true);
 }
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../clean_sync.server/DataProvider.html">DataProvider</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>MongoProvider</strong>(<a href="../mongo_dart/DbCollection.html">DbCollection</a> collection, <a href="../mongo_dart/DbCollection.html">DbCollection</a> _collectionHistory, <a href="../mongo_dart/DbCollection.html">DbCollection</a> _lock) <a class="anchor-link" href="#"
              title="Permalink to MongoProvider.MongoProvider">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
MongoProvider(this.collection, this._collectionHistory, this._lock);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="collection">
<button class="show-code">Code</button>
final <a href="../mongo_dart/DbCollection.html">DbCollection</a>         <strong>collection</strong> <a class="anchor-link"
            href="#collection"
            title="Permalink to MongoProvider.collection">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final DbCollection collection
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="add">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> <strong>add</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a> data, <a href="http://api.dartlang.org/dart_core/String.html">String</a> author) <a class="anchor-link" href="#add"
              title="Permalink to MongoProvider.add">#</a></h4>
<div class="doc">
<pre class="source">
Future add(Map data, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     data[VERSION_FIELD_NAME] = nextVersion;
     return collection.insert(data);
   }).then((_) =&gt;
     _collectionHistory.insert({
       "before" : {},
       "after" : data,
       "change" : {},
       "action" : "add",
       "author" : author,
       "version" : nextVersion
     }),
   onError: (e) {
     print(e);
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks());
}
</pre>
</div>
</div>
<div class="method"><h4 id="change">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> <strong>change</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> _id, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a> change, <a href="http://api.dartlang.org/dart_core/String.html">String</a> author) <a class="anchor-link" href="#change"
              title="Permalink to MongoProvider.change">#</a></h4>
<div class="doc">
<pre class="source">
Future change(String _id, Map change, String author) {
 num nextVersion;
 Map newRecord;
 return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
   .then((Map record) {
     if(record == null) {
       throw new MongoException(null,
           'Change was not applied, document with id $_id does not exist.');
     } else {
       return _maxVersion.then((version) {
         nextVersion = version + 1;
         newRecord = new Map.from(record);
         newRecord.addAll(change);
         newRecord[VERSION_FIELD_NAME] = nextVersion;
         return collection.save(newRecord);
       }).then((_) =&gt;
         _collectionHistory.insert({
           "before" : record,
           "after" : newRecord,
           "change" : change,
           "action" : "change",
           "author" : author,
           "version" : nextVersion
         }));
     }
   },
   onError: (e) {
     print(e);
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks());
}
</pre>
</div>
</div>
<div class="method"><h4 id="data">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&gt; <strong>data</strong>() <a class="anchor-link" href="#data"
              title="Permalink to MongoProvider.data">#</a></h4>
<div class="doc">
<p>Returns data and version of this data.</p>
<pre class="source">
Future&lt;Map&gt; data() {
 Map selector = _selectorList.isEmpty ? {} : {AND: _selectorList};
 print(selector);
 return collection.find(selector).toList().then((data) {
   var version = data.length == 0 ? 0 :
     data.map((item) =&gt; item['__clean_version']).reduce(max);
   return {'data': data, 'version': version};
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="diffFromVersion">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&gt; <strong>diffFromVersion</strong>(<a href="http://api.dartlang.org/dart_core/num.html">num</a> version) <a class="anchor-link" href="#diffFromVersion"
              title="Permalink to MongoProvider.diffFromVersion">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns collection of items in the following form:
 {'diff': [List<Map>]} or
 {'diff': null, 'data': [List<Map>] data, 'version': <a class="crossref" href="../dart_core/num.html">num</a> version_num}</p>
<div class="docs-inherited-from">docs inherited from <a href="../clean_sync.server/DataProvider.html">DataProvider</a> </div></div>
<pre class="source">
Future&lt;Map&gt; diffFromVersion(num version) {
 try{
   return _diffFromVersion(version).then((d) =&gt; {'diff': d});
 } on DiffNotPossibleException catch(e) {
   return data().then((d) {
     d['diff'] = null;
     return d;
   });
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="find">
<button class="show-code">Code</button>
<a href="../clean_sync.server/MongoProvider.html">MongoProvider</a> <strong>find</strong>(<a href="http://api.dartlang.org/dart_core/Map.html">Map</a> params) <a class="anchor-link" href="#find"
              title="Permalink to MongoProvider.find">#</a></h4>
<div class="doc">
<pre class="source">
MongoProvider find(Map params) {
 var mp = new MongoProvider(collection, _collectionHistory, _lock);
 mp._selectorList = new List.from(this._selectorList);
 mp._selectorList.add(params);
 return mp;
}
</pre>
</div>
</div>
<div class="method"><h4 id="remove">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> <strong>remove</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> _id, <a href="http://api.dartlang.org/dart_core/String.html">String</a> author) <a class="anchor-link" href="#remove"
              title="Permalink to MongoProvider.remove">#</a></h4>
<div class="doc">
<pre class="source">
Future remove(String _id, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     return collection.findOne({'_id': _id});
   }).then((record) {
     if (record == null) {
       return true;
     } else {
       return collection.remove({'_id': _id}).then((_) =&gt;
         _collectionHistory.insert({
           "before" : record,
           "after" : {},
           "change" : {},
           "action" : "remove",
           "author" : author,
           "version" : nextVersion
       }));
     }
   },
   onError: (e) {
     print(e);
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks());
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
